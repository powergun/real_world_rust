extern crate bcrypt;

#[allow(unused_imports)]
use bcrypt::{hash, verify, BcryptError};

#[allow(dead_code)]
#[derive(Debug)]
struct User {
    uname: String,
    pass_hash: String,
}

#[allow(dead_code)]
impl User {
    // the larger the cost value, the slower/securer the enc
    // process; 5-7 faster, less secure; 10 slow (2s), secure
    fn new(uname: String, pwd: &str) -> Result<Self, BcryptError> {
        Ok(User {
            uname,
            pass_hash: hash(pwd, 10)?,
        })
    }

    fn verify(&self, pwd: &str) -> bool {
        verify(pwd, &self.pass_hash).unwrap_or(false)
    }
}
#[test]
fn demo_bycrypt_password_hashing_and_verifying() {
    // hash string contains salt (randomly generated bytes)
    // therefore two runs of hash() can produce two different
    // hash string;
    // must use verify to check the password
    let doom = User::new("doom".to_string(), "iddqd").expect("fail to encrypt password");
    assert_eq!(doom.verify("iddqd"), true);
    assert_eq!(doom.verify("idkfa"), false);

    println!("{:?}", doom);
}
